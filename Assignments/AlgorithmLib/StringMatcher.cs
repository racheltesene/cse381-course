/* CSE 381 - String Matcher
*  (c) BYU-Idaho - It is an honor code violation to post this
*  file completed in a public file sharing site. F4.
*
*  Instructions: Implement the Match and BuildTable functions per the instructions
*  in the comments.  Run all tests in StringMatcherTest.cs to verify your code.
*/


namespace AlgorithmLib
{
    public static class StringMatcher
    {
        /* Match function that searches for all occurrences of `pattern` in `text`
         * using a finite state machine (FSM) table generated by `BuildTable`.
         * This method returns the indices of the last character of each match in `text`.
         */
        public static List<int> Match(string text, string pattern, List<char> inputs)
        {
            // Initialize a list to store indices where the pattern is matched
            var matchIndices = new List<int>();
            
            // Build the FSM table for the given pattern and input character set
            var fsmTable = BuildTable(pattern, inputs);
            
            int currentState = 0;  // Start at the initial state of FSM
            for (int i = 0; i < text.Length; i++)
            {
                // If character from text is not in the valid inputs, reset current state
                if (!inputs.Contains(text[i]))
                {
                    currentState = 0;
                    continue;
                }

                // Transition to the next state based on the current character
                currentState = fsmTable[currentState][text[i]];

                // If current state equals the length of the pattern, a match is found
                if (currentState == pattern.Length)
                {
                    // Record the index of the last character of the match
                    matchIndices.Add(i);
                    // Reset state to the state of the longest prefix
                    currentState = fsmTable[currentState][text[i]];
                }
            }

            return matchIndices;
        }

        /* BuildTable function that creates an FSM table for `pattern` with states
         * based on KMP partial match logic, defining transitions based on valid input characters.
         */
        public static List<Dictionary<char, int>> BuildTable(string pattern, List<char> inputs)
        {
            // Initialize the FSM table as a list of dictionaries for each state
            var fsmTable = new List<Dictionary<char, int>>();
            
            int patternLength = pattern.Length;
            
            // Start each state with a dictionary of transitions for each input character
            for (int state = 0; state <= patternLength; state++)
            {
                fsmTable.Add(new Dictionary<char, int>());
                foreach (char input in inputs)
                {
                    int nextState = GetNextState(pattern, state, input);
                    fsmTable[state][input] = nextState;
                }
            }

            return fsmTable;
        }

        /* Helper function that calculates the next state for the FSM based on
         * the current state, the `pattern`, and the `currentChar` encountered.
         */
        private static int GetNextState(string pattern, int state, char currentChar)
        {
            // If character matches the next character in the pattern, move to next state
            if (state < pattern.Length && currentChar == pattern[state])
                return state + 1;

            // Calculate the longest prefix which is also a suffix
            for (int next = state; next > 0; next--)
            {
                if (pattern[next - 1] == currentChar)
                {
                    int i;
                    for (i = 0; i < next - 1; i++)
                    {
                        if (pattern[i] != pattern[state - next + 1 + i])
                            break;
                    }
                    if (i == next - 1)
                        return next;
                }
            }

            return 0; // If no proper prefix found, return to state 0
        }
    }
}
